import time
import threading
from datetime import datetime, timezone, timedelta
import ccxt
import numpy as np
from telebot import TeleBot, types
import requests
import logging
import json
import os
import sys
import traceback

def get_vietnam_time(utc_time):
    """Chuyển đổi thời gian từ UTC sang giờ Việt Nam"""
    if isinstance(utc_time, str):
        utc_time = datetime.strptime(utc_time, '%Y-%m-%d %H:%M:%S')
    vietnam_tz = timezone(timedelta(hours=7))
    return utc_time.replace(tzinfo=timezone.utc).astimezone(vietnam_tz)

def get_next_5min_mark():
    """Lấy mốc 5 phút tiếp theo"""
    now = datetime.now(timezone.utc)
    minutes = now.minute
    next_5min = ((minutes // 5) + 1) * 5
    if next_5min == 60:
        next_time = now.replace(minute=0, second=0, microsecond=0) + timedelta(hours=1)
    else:
        next_time = now.replace(minute=next_5min, second=0, microsecond=0)
    return next_time

# Thiết lập logging cơ bản trước khi khởi tạo bot
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s [%(levelname)s] %(threadName)s - %(filename)s:%(lineno)d - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

class PricePatternAnalyzer:
        def __init__(self, max_bars=200):
                self.max_bars = max_bars
                self.price_history = []
                self.time_history = []
                self.pivots = []
                self.patterns = {
                    "mẫu hình tăng để giảm": [
                        ["HH", "HL", "HH", "HL", "HH"],
                        ["LH", "HL", "HH", "HL", "HH"],
                        ["HH", "HH", "HH"],
                        ["HH", "HL", "HH", "HH"]
                    ],
                    "mẫu hình giảm để tăng": [
                        ["LL", "LL", "LH", "LL"],
                        ["LL", "LH", "LL", "LH", "LL"],
                        ["LL", "LL", "LL"],
                        ["LL", "LH", "LL", "LH", "LL"],
                        ["LL", "LH", "LL"]
                    ]
                }
                # Tạo logger riêng cho pattern analyzer
                self.logger = logging.getLogger('PatternAnalyzer')
                self.logger.setLevel(logging.DEBUG)
                
                # Tạo thư mục logs nếu chưa có
                os.makedirs('logs', exist_ok=True)
                
                # Tạo file handler cho pattern analysis
                pattern_handler = logging.FileHandler(
                    f'logs/pattern_analysis_{datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")}.log',
                    encoding='utf-8'
                )
                pattern_handler.setFormatter(
                    logging.Formatter('%(asctime)s [%(levelname)s] - %(message)s')
                )
                self.logger.addHandler(pattern_handler)
                self.logger.info("=== Pattern Analyzer Started ===")

        def find_pivots(self, prices, times, lb=5, rb=5):
                """Tìm các điểm pivot (High và Low) với timestamp"""
                pivots = []
                for i in range(lb, len(prices) - rb):
                    # Kiểm tra Pivot High
                    is_ph = True
                    for j in range(i-lb, i+rb+1):
                        if j != i and prices[j] >= prices[i]:
                            is_ph = False
                            break
                    if is_ph:
                        pivots.append(("H", prices[i], i, times[i]))
                        vn_time = get_vietnam_time(times[i])
                        self.logger.info(f"Found Pivot High: ${prices[i]:,.2f} at {vn_time.strftime('%Y-%m-%d %H:%M:%S')} VN")
                        continue

                    # Kiểm tra Pivot Low
                    is_pl = True
                    for j in range(i-lb, i+rb+1):
                        if j != i and prices[j] <= prices[i]:
                            is_pl = False
                            break
                    if is_pl:
                        pivots.append(("L", prices[i], i, times[i]))
                        vn_time = get_vietnam_time(times[i])
                        self.logger.info(f"Found Pivot Low: ${prices[i]:,.2f} at {vn_time.strftime('%Y-%m-%d %H:%M:%S')} VN")

                return pivots

        def classify_pivots(self, pivots):
                """Phân loại các điểm pivot thành HH, HL, LH, LL với logging"""
                classified = []
                for i in range(1, len(pivots)):
                    current = pivots[i]
                    previous = pivots[i-1]
                            
                    current_time_vn = get_vietnam_time(current[3])
                    previous_time_vn = get_vietnam_time(previous[3])
                            
                    if current[0] == "H":
                        if current[1] > previous[1]:
                            classified.append("HH")
                            self.logger.info(
                                f"Higher High: ${current[1]:,.2f} at {current_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN " 
                                f"(Previous: ${previous[1]:,.2f} at {previous_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN)"
                            )
                        else:
                            classified.append("LH")
                            self.logger.info(
                                f"Lower High: ${current[1]:,.2f} at {current_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN "
                                f"(Previous: ${previous[1]:,.2f} at {previous_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN)"
                            )
                    else:  # current[0] == "L"
                        if current[1] < previous[1]:
                            classified.append("LL")
                            self.logger.info(
                                f"Lower Low: ${current[1]:,.2f} at {current_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN "
                                f"(Previous: ${previous[1]:,.2f} at {previous_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN)"
                            )
                        else:
                            classified.append("HL")
                            self.logger.info(
                                f"Higher Low: ${current[1]:,.2f} at {current_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN "
                                f"(Previous: ${previous[1]:,.2f} at {previous_time_vn.strftime('%Y-%m-%d %H:%M:%S')} VN)"
                            )
                                    
                return classified

        def find_patterns(self, classified_pivots):
                """Tìm các mẫu hình đã định nghĩa"""
                found_patterns = []
                
                # Chuyển classified_pivots thành chuỗi để dễ so sánh
                pivot_string = ",".join(classified_pivots)
                self.logger.debug(f"Analyzing pivot string: {pivot_string}")
                
                # Kiểm tra từng nhóm mẫu hình
                for pattern_group, patterns in self.patterns.items():
                    for pattern in patterns:
                        pattern_string = ",".join(pattern)
                        if pattern_string in pivot_string:
                            found_patterns.append(pattern_group)
                            self.logger.info(f"Found pattern: {pattern_group} (matched: {pattern_string})")
                            break
                            
                return list(set(found_patterns))

        def analyze(self, new_price, timestamp):
                """Phân tích giá mới và trả về các mẫu hình tìm thấy"""
                # Chuyển đổi timestamp sang giờ VN cho logging
                vn_time = get_vietnam_time(timestamp)
                # Log mỗi khi có giá mới
                self.logger.info(f"\n=== Bắt đầu phân tích giá lúc {vn_time.strftime('%Y-%m-%d %H:%M:%S')} VN ===")
                self.logger.info(f"Giá mới: ${new_price:,.2f}")
                
                # Thêm giá mới vào lịch sử
                self.price_history.append(new_price)
                self.time_history.append(timestamp)
                
                # Log thông tin về dữ liệu
                self.logger.info(f"Số điểm dữ liệu hiện có: {len(self.price_history)}")
                
                # Kiểm tra và cắt bớt nếu vượt quá max_bars
                if len(self.price_history) > self.max_bars:
                    self.price_history.pop(0)
                    self.time_history.pop(0)
                    self.logger.info(f"Đã cắt bớt dữ liệu xuống {self.max_bars} điểm")
                    
                # Kiểm tra số lượng điểm dữ liệu
                if len(self.price_history) < 10:
                    self.logger.info(f"⏳ Đang chờ thêm dữ liệu... (Có: {len(self.price_history)}/10 điểm)")
                    self.logger.info("=== Kết thúc phân tích ===\n")
                    return []
                    
                # Log lịch sử giá với giờ VN
                self.logger.info("\nLịch sử giá:")
                for i, (price, time) in enumerate(zip(self.price_history[-5:], self.time_history[-5:]), 1):
                    vn_time = get_vietnam_time(time)
                    self.logger.info(f"{i}. ${price:,.2f} tại {vn_time.strftime('%H:%M:%S')}")
                
                # Tìm các điểm pivot
                self.logger.info("\nTìm kiếm điểm pivot...")
                pivots = self.find_pivots(self.price_history, self.time_history)
                if not pivots:
                    self.logger.info("❌ Không tìm thấy điểm pivot")
                    self.logger.info("=== Kết thúc phân tích ===\n")
                    return []
                
                # Phân loại các điểm pivot
                self.logger.info("\nPhân loại các điểm pivot...")
                classified_pivots = self.classify_pivots(pivots)
                if not classified_pivots:
                    self.logger.info("❌ Không có mẫu hình để phân loại")
                    self.logger.info("=== Kết thúc phân tích ===\n")
                    return []
                
                # Tìm kiếm mẫu hình
                self.logger.info("\nTìm kiếm mẫu hình...")
                patterns = self.find_patterns(classified_pivots)
                
                if patterns:
                    self.logger.info(f"✅ Đã tìm thấy mẫu hình: {patterns}")
                else:
                    self.logger.info("❌ Không phát hiện mẫu hình")
                
                self.logger.info("=== Kết thúc phân tích ===\n")
                return patterns
        
class PriceAlertBot:
    def __init__(self):
        try:
            # Khởi tạo các thông số cơ bản
            self.API_TOKEN = '7637023247:AAG_utVTC0rXyfute9xsBdh-IrTUE3432o8'
            self.CHAT_ID = 7662080576
            self.EXCHANGE_RATE_API_KEY = '6d4a617a86b3985f2dc473b4'
            
            # Tạo thư mục logs nếu chưa có
            os.makedirs('logs', exist_ok=True)
            
            # Thiết lập file logging
            log_file = f'logs/bot_{datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")}.log'
            file_handler = logging.FileHandler(log_file, 'w', 'utf-8')
            file_handler.setFormatter(
                logging.Formatter('%(asctime)s [%(levelname)s] %(threadName)s - %(filename)s:%(lineno)d - %(message)s')
            )
            logging.getLogger().addHandler(file_handler)
            
            logging.info("=== KHỞI TẠO BOT ===")
            
            # Khởi tạo bot
            logging.info("Đang khởi tạo bot instance...")
            self.bot = TeleBot(self.API_TOKEN)
            
            # Kiểm tra kết nối
            bot_info = self.bot.get_me()
            logging.info(f"Kết nối thành công tới bot: {bot_info.username}")
            
            # Khởi tạo biến theo dõi giá
            self.gia_muc_tieu = {'BTC': None, 'AUD': None}
            self.dang_cho_nhap_gia = {}
            
            # Thêm các analyzers
            self.btc_analyzer = PricePatternAnalyzer()
            
            # Thiết lập handlers
            self.setup_handlers()
            
            logging.info("Khởi tạo bot thành công")
            
        except Exception as e:
            logging.error(f"Lỗi khởi tạo bot: {str(e)}")
            logging.error(traceback.format_exc())
            raise

def monitor_prices(self):
                logging.info("Bắt đầu theo dõi giá...")
                
                while True:
                    try:
                        current_time = datetime.now(timezone.utc)
                        next_time = get_next_5min_mark()
                        wait_seconds = (next_time - current_time).total_seconds()
                        
                        # Đợi đến mốc 5 phút tiếp theo
                        if wait_seconds > 0:
                            time.sleep(wait_seconds)
                        
                        # Lấy giá và phân tích tại mốc thời gian chính xác
                        current_time = datetime.now(timezone.utc)
                        vietnam_time = get_vietnam_time(current_time)
                        
                        # Kiểm tra BTC
                        price = self.get_btc_price()
                        if price:
                            # Phân tích mẫu hình với timestamp
                            patterns = self.btc_analyzer.analyze(float(price), current_time)
                            for pattern in patterns:
                                message = (
                                    f"🔄 Cảnh báo BTC ({vietnam_time.strftime('%Y-%m-%d %H:%M:%S')} VN)\n"
                                    f"Giá hiện tại: ${float(price):,.2f}\n"
                                    f"Mẫu hình: {pattern}"
                                )
                                self.bot.send_message(self.CHAT_ID, message)
                                logging.info(f"Đã gửi cảnh báo mẫu hình: {pattern}")
                            
                            # Kiểm tra giá mục tiêu
                            if self.gia_muc_tieu['BTC'] and float(price) >= self.gia_muc_tieu['BTC']:
                                self.bot.send_message(
                                    self.CHAT_ID,
                                    f"🚨 Cảnh báo BTC đạt mục tiêu: ${float(price):,.2f}"
                                )
                                self.gia_muc_tieu['BTC'] = None
            
                    except Exception as e:
                        logging.error(f"Lỗi theo dõi giá: {str(e)}")
                        logging.error(traceback.format_exc())

    def setup_handlers(self):
        @self.bot.message_handler(commands=['start', 'help'])
        def send_welcome(message):
            self.bot.reply_to(message, 
                "Xin chào! Tôi là bot cảnh báo giá.\n"
                "Sử dụng /btc để đặt cảnh báo BTC\n"
                "Sử dụng /aud để đặt cảnh báo AUD\n"
                "Sử dụng /reset để xóa tất cả cảnh báo")

        @self.bot.message_handler(commands=['reset'])
        def handle_reset(message):
            try:
                # Lưu số lượng cảnh báo trước khi reset
                btc_alert = "BTC" if self.gia_muc_tieu['BTC'] else None
                aud_alert = "AUD" if self.gia_muc_tieu['AUD'] else None
                alerts_to_reset = [x for x in [btc_alert, aud_alert] if x]
                
                # Reset tất cả giá mục tiêu về None
                self.gia_muc_tieu = {'BTC': None, 'AUD': None}
                self.dang_cho_nhap_gia = {}
                
                # Tạo thông báo phản hồi
                if alerts_to_reset:
                    response = f"✅ Đã xóa {len(alerts_to_reset)} cảnh báo giá: {', '.join(alerts_to_reset)}"
                    logging.info(f"Đã reset cảnh báo giá: {alerts_to_reset}")
                else:
                    response = "ℹ️ Không có cảnh báo giá nào để xóa"
                    logging.info("Lệnh reset được gọi khi không có cảnh báo giá")
                
                self.bot.reply_to(message, response)
                
            except Exception as e:
                error_msg = f"❌ Lỗi khi reset cảnh báo giá: {str(e)}"
                logging.error(error_msg)
                logging.error(traceback.format_exc())
                self.bot.reply_to(message, error_msg)

        @self.bot.message_handler(commands=['btc'])
        def handle_btc(message):
            try:
                price = self.get_btc_price()
                if price:
                    self.dang_cho_nhap_gia[message.chat.id] = 'BTC'
                    self.bot.reply_to(message, 
                        f"Giá BTC hiện tại: ${price:,.2f}\n"
                        f"Vui lòng nhập giá mục tiêu:")
                else:
                    self.bot.reply_to(message, "Không thể lấy giá BTC. Vui lòng thử lại sau.")
            except Exception as e:
                logging.error(f"Lỗi xử lý lệnh BTC: {str(e)}")

        @self.bot.message_handler(commands=['aud'])
        def handle_aud(message):
            try:
                price = self.get_aud_price()
                if price:
                    self.dang_cho_nhap_gia[message.chat.id] = 'AUD'
                    self.bot.reply_to(message,
                        f"Giá USD/AUD hiện tại: {price:.5f}\n"
                        f"Vui lòng nhập giá mục tiêu:")
                else:
                    self.bot.reply_to(message, "Không thể lấy giá AUD. Vui lòng thử lại sau.")
            except Exception as e:
                logging.error(f"Lỗi xử lý lệnh AUD: {str(e)}")

        @self.bot.message_handler(func=lambda message: True)
        def handle_price_input(message):
            try:
                chat_id = message.chat.id
                if chat_id not in self.dang_cho_nhap_gia:
                    return

                currency = self.dang_cho_nhap_gia[chat_id]
                try:
                    target_price = float(message.text)
                    self.gia_muc_tieu[currency] = target_price
                    self.bot.reply_to(message, 
                        f"Đã đặt cảnh báo cho {currency} tại mức: {target_price:.5f}")
                except ValueError:
                    self.bot.reply_to(message, "Giá không hợp lệ. Vui lòng nhập một số.")
                
                del self.dang_cho_nhap_gia[chat_id]
                
            except Exception as e:
                logging.error(f"Lỗi xử lý nhập giá: {str(e)}")

    def get_btc_price(self):
        try:
            response = requests.get(
                'https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT',
                timeout=10
            )
            response.raise_for_status()
            data = response.json()
            price = float(data['price'])
            logging.debug(f"Giá BTC: {price}")
            return price
        except Exception as e:
            logging.error(f"Lỗi lấy giá BTC: {str(e)}")
            return None

    def get_aud_price(self):
        try:
            response = requests.get(
                f'https://v6.exchangerate-api.com/v6/{self.EXCHANGE_RATE_API_KEY}/latest/USD',
                timeout=10
            )
            response.raise_for_status()
            data = response.json()
            
            # Chuyển đổi từ AUD/USD sang USD/AUD
            aud_usd = float(data['conversion_rates']['AUD'])
            usd_aud = 1 / aud_usd
            
            logging.debug(f"Giá USD/AUD: {usd_aud:.5f}")
            return usd_aud
            
        except requests.exceptions.RequestException as e:
            logging.error(f"Lỗi kết nối API AUD: {str(e)}")
            return None
        except Exception as e:
            logging.error(f"Lỗi lấy giá AUD: {str(e)}")
            return None

    def run(self):
        try:
            # Khởi động thread theo dõi giá
            monitor_thread = threading.Thread(
                target=self.monitor_prices,
                daemon=True,
                name="PriceMonitor"
            )
            monitor_thread.start()
            logging.info("Đã khởi động thread theo dõi giá")
            
            # Thông báo khởi động
            self.bot.send_message(self.CHAT_ID, "Bot đã sẵn sàng!")
            logging.info("Đã gửi thông báo khởi động")
            
            # Bắt đầu polling
            logging.info("Bắt đầu polling...")
            self.bot.infinity_polling(timeout=10, long_polling_timeout=5)
            
        except Exception as e:
            logging.error(f"Lỗi chạy bot: {str(e)}")
            raise

if __name__ == "__main__":
    try:
        bot = PriceAlertBot()
        bot.run()
    except KeyboardInterrupt:
        logging.info("Dừng bot bởi người dùng")
        sys.exit(0)
    except Exception as e:
        logging.error(f"Lỗi không xác định: {str(e)}")
        logging.error(traceback.format_exc())
        sys.exit(1)
